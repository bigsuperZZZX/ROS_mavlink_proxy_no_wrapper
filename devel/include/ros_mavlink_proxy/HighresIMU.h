// Generated by gencpp from file ros_mavlink_proxy/HighresIMU.msg
// DO NOT EDIT!


#ifndef ROS_MAVLINK_PROXY_MESSAGE_HIGHRESIMU_H
#define ROS_MAVLINK_PROXY_MESSAGE_HIGHRESIMU_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ros_mavlink_proxy
{
template <class ContainerAllocator>
struct HighresIMU_
{
  typedef HighresIMU_<ContainerAllocator> Type;

  HighresIMU_()
    : header()
    , time_usec(0)
    , xacc(0.0)
    , yacc(0.0)
    , zacc(0.0)
    , xgyro(0.0)
    , ygyro(0.0)
    , zgyro(0.0)
    , xmag(0.0)
    , ymag(0.0)
    , zmag(0.0)
    , abs_pressure(0.0)
    , diff_pressure(0.0)
    , pressure_alt(0.0)
    , temperature(0.0)
    , fields_updated(0)
    , id(0)
    , origin_system_id(0)  {
    }
  HighresIMU_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , time_usec(0)
    , xacc(0.0)
    , yacc(0.0)
    , zacc(0.0)
    , xgyro(0.0)
    , ygyro(0.0)
    , zgyro(0.0)
    , xmag(0.0)
    , ymag(0.0)
    , zmag(0.0)
    , abs_pressure(0.0)
    , diff_pressure(0.0)
    , pressure_alt(0.0)
    , temperature(0.0)
    , fields_updated(0)
    , id(0)
    , origin_system_id(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint64_t _time_usec_type;
  _time_usec_type time_usec;

   typedef float _xacc_type;
  _xacc_type xacc;

   typedef float _yacc_type;
  _yacc_type yacc;

   typedef float _zacc_type;
  _zacc_type zacc;

   typedef float _xgyro_type;
  _xgyro_type xgyro;

   typedef float _ygyro_type;
  _ygyro_type ygyro;

   typedef float _zgyro_type;
  _zgyro_type zgyro;

   typedef float _xmag_type;
  _xmag_type xmag;

   typedef float _ymag_type;
  _ymag_type ymag;

   typedef float _zmag_type;
  _zmag_type zmag;

   typedef float _abs_pressure_type;
  _abs_pressure_type abs_pressure;

   typedef float _diff_pressure_type;
  _diff_pressure_type diff_pressure;

   typedef float _pressure_alt_type;
  _pressure_alt_type pressure_alt;

   typedef float _temperature_type;
  _temperature_type temperature;

   typedef uint16_t _fields_updated_type;
  _fields_updated_type fields_updated;

   typedef uint8_t _id_type;
  _id_type id;

   typedef uint8_t _origin_system_id_type;
  _origin_system_id_type origin_system_id;





  typedef boost::shared_ptr< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> const> ConstPtr;

}; // struct HighresIMU_

typedef ::ros_mavlink_proxy::HighresIMU_<std::allocator<void> > HighresIMU;

typedef boost::shared_ptr< ::ros_mavlink_proxy::HighresIMU > HighresIMUPtr;
typedef boost::shared_ptr< ::ros_mavlink_proxy::HighresIMU const> HighresIMUConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ros_mavlink_proxy

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'ros_mavlink_proxy': ['/home/myros/PX4learn/ROS_mavlink_proxy/src/ros_mavlink_proxy/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
{
  static const char* value()
  {
    return "02e220874ef254dd246c5482f83c54a1";
  }

  static const char* value(const ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x02e220874ef254ddULL;
  static const uint64_t static_value2 = 0x246c5482f83c54a1ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_mavlink_proxy/HighresIMU";
  }

  static const char* value(const ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Message for HIGHRES_IMU ( #105 )\n\
# zxzxzxzx\n\
\n\
std_msgs/Header header\n\
\n\
uint64 time_usec	#us	Timestamp (UNIX Epoch time or time since system boot). The receiving end can infer timestamp format (since 1.1.1970 or since system boot) by checking for the magnitude the number.\n\
float32 xacc		#m/s/s	X acceleration\n\
float32 yacc		#m/s/s	Y acceleration\n\
float32 zacc		#m/s/s	Z acceleration\n\
float32 xgyro		#rad/s	Angular speed around X axis\n\
float32 ygyro		#rad/s	Angular speed around Y axis\n\
float32 zgyro		#rad/s	Angular speed around Z axis\n\
float32 xmag		#gauss	X Magnetic field\n\
float32 ymag		#gauss	Y Magnetic field\n\
float32 zmag		#gauss	Z Magnetic field\n\
float32 abs_pressure	#mbar	Absolute pressure\n\
float32 diff_pressure	#mbar	Differential pressure\n\
float32 pressure_alt	#	Altitude calculated from pressure\n\
float32 temperature	#degC	Temperature\n\
uint16 fields_updated	#	Bitmap for fields that have updated since last message, bit 0 = xacc, bit 12: temperature\n\
uint8 id 		#       Id. Ids are numbered from 0 and map to IMUs numbered from 1 (e.g. IMU1 will have a message with id=0)\n\
\n\
uint8 origin_system_id\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.time_usec);
      stream.next(m.xacc);
      stream.next(m.yacc);
      stream.next(m.zacc);
      stream.next(m.xgyro);
      stream.next(m.ygyro);
      stream.next(m.zgyro);
      stream.next(m.xmag);
      stream.next(m.ymag);
      stream.next(m.zmag);
      stream.next(m.abs_pressure);
      stream.next(m.diff_pressure);
      stream.next(m.pressure_alt);
      stream.next(m.temperature);
      stream.next(m.fields_updated);
      stream.next(m.id);
      stream.next(m.origin_system_id);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct HighresIMU_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_mavlink_proxy::HighresIMU_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "time_usec: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.time_usec);
    s << indent << "xacc: ";
    Printer<float>::stream(s, indent + "  ", v.xacc);
    s << indent << "yacc: ";
    Printer<float>::stream(s, indent + "  ", v.yacc);
    s << indent << "zacc: ";
    Printer<float>::stream(s, indent + "  ", v.zacc);
    s << indent << "xgyro: ";
    Printer<float>::stream(s, indent + "  ", v.xgyro);
    s << indent << "ygyro: ";
    Printer<float>::stream(s, indent + "  ", v.ygyro);
    s << indent << "zgyro: ";
    Printer<float>::stream(s, indent + "  ", v.zgyro);
    s << indent << "xmag: ";
    Printer<float>::stream(s, indent + "  ", v.xmag);
    s << indent << "ymag: ";
    Printer<float>::stream(s, indent + "  ", v.ymag);
    s << indent << "zmag: ";
    Printer<float>::stream(s, indent + "  ", v.zmag);
    s << indent << "abs_pressure: ";
    Printer<float>::stream(s, indent + "  ", v.abs_pressure);
    s << indent << "diff_pressure: ";
    Printer<float>::stream(s, indent + "  ", v.diff_pressure);
    s << indent << "pressure_alt: ";
    Printer<float>::stream(s, indent + "  ", v.pressure_alt);
    s << indent << "temperature: ";
    Printer<float>::stream(s, indent + "  ", v.temperature);
    s << indent << "fields_updated: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.fields_updated);
    s << indent << "id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.id);
    s << indent << "origin_system_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.origin_system_id);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_MAVLINK_PROXY_MESSAGE_HIGHRESIMU_H
