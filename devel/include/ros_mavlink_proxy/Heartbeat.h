// Generated by gencpp from file ros_mavlink_proxy/Heartbeat.msg
// DO NOT EDIT!


#ifndef ROS_MAVLINK_PROXY_MESSAGE_HEARTBEAT_H
#define ROS_MAVLINK_PROXY_MESSAGE_HEARTBEAT_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ros_mavlink_proxy
{
template <class ContainerAllocator>
struct Heartbeat_
{
  typedef Heartbeat_<ContainerAllocator> Type;

  Heartbeat_()
    : header()
    , type(0)
    , autopilot(0)
    , base_mode(0)
    , custom_mode(0)
    , system_status(0)
    , mavlink_version(0)
    , origin_system_id(0)  {
    }
  Heartbeat_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , type(0)
    , autopilot(0)
    , base_mode(0)
    , custom_mode(0)
    , system_status(0)
    , mavlink_version(0)
    , origin_system_id(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _type_type;
  _type_type type;

   typedef uint8_t _autopilot_type;
  _autopilot_type autopilot;

   typedef uint8_t _base_mode_type;
  _base_mode_type base_mode;

   typedef uint32_t _custom_mode_type;
  _custom_mode_type custom_mode;

   typedef uint8_t _system_status_type;
  _system_status_type system_status;

   typedef uint8_t _mavlink_version_type;
  _mavlink_version_type mavlink_version;

   typedef uint8_t _origin_system_id_type;
  _origin_system_id_type origin_system_id;





  typedef boost::shared_ptr< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> const> ConstPtr;

}; // struct Heartbeat_

typedef ::ros_mavlink_proxy::Heartbeat_<std::allocator<void> > Heartbeat;

typedef boost::shared_ptr< ::ros_mavlink_proxy::Heartbeat > HeartbeatPtr;
typedef boost::shared_ptr< ::ros_mavlink_proxy::Heartbeat const> HeartbeatConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ros_mavlink_proxy

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'ros_mavlink_proxy': ['/home/myros/PX4learn/ROS_mavlink_proxy/src/ros_mavlink_proxy/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6cde59cd898d4476dd26d5124e92dc91";
  }

  static const char* value(const ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6cde59cd898d4476ULL;
  static const uint64_t static_value2 = 0xdd26d5124e92dc91ULL;
};

template<class ContainerAllocator>
struct DataType< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ros_mavlink_proxy/Heartbeat";
  }

  static const char* value(const ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Message for HEARTBEAT ( #0 )\n\
# zxzxzxzx\n\
\n\
std_msgs/Header header\n\
\n\
uint8 type			#Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.\n\
uint8 autopilot		#Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.\n\
uint8 base_mode		#System mode bitmap.\n\
uint32 custom_mode		#A bitfield for use for autopilot-specific flags\n\
uint8 system_status		#System status flag.\n\
uint8 mavlink_version		#MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version\n\
\n\
uint8 origin_system_id\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.type);
      stream.next(m.autopilot);
      stream.next(m.base_mode);
      stream.next(m.custom_mode);
      stream.next(m.system_status);
      stream.next(m.mavlink_version);
      stream.next(m.origin_system_id);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Heartbeat_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ros_mavlink_proxy::Heartbeat_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.type);
    s << indent << "autopilot: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.autopilot);
    s << indent << "base_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.base_mode);
    s << indent << "custom_mode: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.custom_mode);
    s << indent << "system_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.system_status);
    s << indent << "mavlink_version: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.mavlink_version);
    s << indent << "origin_system_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.origin_system_id);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROS_MAVLINK_PROXY_MESSAGE_HEARTBEAT_H
